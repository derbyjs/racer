// @ts-check

var EventEmitter = require('events').EventEmitter;
var util = require('../util');
/** @type any */
var Model = require('./Model');

// These events are re-emitted as 'all' events, and they are queued up and
// emitted in sequence, so that events generated by other events are not
// seen in a different order by later listeners
Model.MUTATOR_EVENTS = {
  change: true,
  insert: true,
  remove: true,
  move: true,
  load: true,
  unload: true
};

Model.INITS.push(function(model) {
  EventEmitter.call(this);

  // Set max listeners to unlimited
  model.setMaxListeners(0);

  // Used in async methods to emit an error event if a callback is not supplied.
  // This will throw if there is no handler for model.on('error')
  model.root._defaultCallback = defaultCallback;
  function defaultCallback(err) {
    if (err) model._emitError(err);
  }

  model.root._mutatorEventQueue = null;
  model.root._pass = new Passed({}, {});
  model.root._silent = null;
  model.root._eventContext = null;
});

util.mergeInto(Model.prototype, EventEmitter.prototype);

Model.prototype.wrapCallback = function(cb) {
  if (!cb) return this.root._defaultCallback;
  var model = this;
  return function wrappedCallback() {
    try {
      return cb.apply(this, arguments);
    } catch (err) {
      model._emitError(err);
    }
  };
};

Model.prototype._emitError = function(err, context) {
  var message = (err.message) ? err.message :
    (typeof err === 'string') ? err :
      'Unknown model error';
  if (context) {
    message += ' ' + context;
  }
  if (err.data) {
    try {
      message += ' ' + JSON.stringify(err.data);
    } catch (stringifyErr) {}
  }
  if (err instanceof Error) {
    err.message = message;
  } else {
    err = new Error(message);
  }
  this.emit('error', err);
};

// EventEmitter.prototype.on, EventEmitter.prototype.addListener, and
// EventEmitter.prototype.once return `this`. The Model equivalents return
// the listener instead, since it is made internally for method subscriptions
// and may need to be passed to removeListener.

Model.prototype._emit = EventEmitter.prototype.emit;
Model.prototype.emit = function(type) {
  if (type === 'error') {
    return this._emit.apply(this, arguments);
  }
  if (Model.MUTATOR_EVENTS[type]) {
    if (this._silent) return this;
    // `segments` is almost definitely an array of strings.
    //
    // A search for `.emit(` shows that `segments` is generated from either
    // `Model#_splitPath` or `Model#_dereference`, both of which return an array
    // of strings.
    var segments = arguments[1];
    var eventArgs = arguments[2];
    this._emit(type + 'Immediate', segments, eventArgs);
    if (this.root._mutatorEventQueue) {
      this.root._mutatorEventQueue.push([type, segments, eventArgs]);
      return this;
    }
    this.root._mutatorEventQueue = [];
    this._emit(type, segments, eventArgs);
    this._emit('all', segments, [type].concat(eventArgs));
    while (this.root._mutatorEventQueue.length) {
      var queued = this.root._mutatorEventQueue.shift();
      type = queued[0];
      segments = queued[1];
      eventArgs = queued[2];
      this._emit(type, segments, eventArgs);
      this._emit('all', segments, [type].concat(eventArgs));
    }
    this.root._mutatorEventQueue = null;
    return this;
  }
  return this._emit.apply(this, arguments);
};

Model.prototype._on = EventEmitter.prototype.on;
Model.prototype.addListener =
Model.prototype.on = function(type, pattern, options, cb) {
  var listener = eventListener(this, type, pattern, options, cb);
  this._on(type, listener);
  return listener;
};

Model.prototype.once = function(type, pattern, options, cb) {
  var listener = eventListener(this, type, pattern, options, cb);
  function g() {
    var matches = listener.apply(null, arguments);
    if (matches) this.removeListener(type, g);
  }
  this._on(type, g);
  return g;
};

/**
 * @typedef {Object} ModelOnOptions
 * @property {boolean} [useEventObjects] - If true, the listener is called with
 *   `cb(event: ___Event, captures: string[])`, instead of the legacy var-args
 *   style `cb(captures..., [eventType], eventArgs..., passed)`.
 */

Model.prototype._removeAllListeners = EventEmitter.prototype.removeAllListeners;
Model.prototype.removeAllListeners = function(type, subpattern) {
  // If a pattern is specified without an event type, remove all model event
  // listeners under that pattern for all events
  if (!type) {
    for (var key in this._events) {
      this.removeAllListeners(key, subpattern);
    }
    return this;
  }

  var pattern = this.path(subpattern);
  // If no pattern is specified, remove all listeners like normal
  if (!pattern) {
    if (arguments.length === 0) {
      return this._removeAllListeners();
    }
    return this._removeAllListeners(type);
  }

  // Remove all listeners for an event under a pattern
  var listeners = this.listeners(type);
  var segments = pattern.split('.');
  // Make sure to iterate in reverse, since the array might be
  // mutated as listeners are removed
  for (var i = listeners.length; i--;) {
    var listener = listeners[i];
    if (patternContained(pattern, segments, listener)) {
      this.removeListener(type, listener);
    }
  }
  return this;
};

function patternContained(pattern, segments, listener) {
  var listenerSegments = listener.patternSegments;
  if (!listenerSegments) return false;
  if (pattern === listener.pattern || pattern === '**') return true;
  var len = segments.length;
  if (len > listenerSegments.length) return false;
  for (var i = 0; i < len; i++) {
    if (segments[i] !== listenerSegments[i]) return false;
  }
  return true;
}

Model.prototype.pass = function(object, invert) {
  var model = this._child();
  model._pass = (invert) ?
    new Passed(object, this._pass) :
    new Passed(this._pass, object);
  return model;
};

function Passed(previous, value) {
  for (var key in previous) {
    this[key] = previous[key];
  }
  for (var key in value) {
    this[key] = value[key];
  }
}

/**
 * The returned Model will or won't trigger event handlers when the model emits
 * events, depending on `value`
 * @param {Boolean|Null} value defaults to true
 * @return {Model}
 */
Model.prototype.silent = function(value) {
  var model = this._child();
  model._silent = (value == null) ? true : value;
  return model;
};

Model.prototype.eventContext = function(value) {
  var model = this._child();
  model._eventContext = value;
  return model;
};

Model.prototype.removeContextListeners = function(value) {
  if (arguments.length === 0) {
    value = this._eventContext;
  }
  // Remove all events created within a given context
  for (var type in this._events) {
    var listeners = this.listeners(type);
    // Make sure to iterate in reverse, since the array might be
    // mutated as listeners are removed
    for (var i = listeners.length; i--;) {
      var listener = listeners[i];
      if (listener.eventContext === value) {
        this.removeListener(type, listener);
      }
    }
  }
  return this;
};

/**
 * @param {Model} model
 * @param {string} eventType
 */
function eventListener(model, eventType, arg2, arg3, arg4) {
  var subpattern, options, cb;
  if (arg4) {
    // on(eventType, path, options, cb)
    subpattern = arg2;
    options = arg3;
    cb = arg4;
  } else if (arg3) {
    // on(eventType, path, cb)
    // on(eventType, options, cb)
    cb = arg3;
    if (model.isPath(arg2)) {
      subpattern = arg2;
    } else {
      options = arg2;
    }
  } else { // if (arg2)
    // on(eventType, cb)
    cb = arg2;
  }
  if (options) {
    if (options.useEventObjects) {
      var useEventObjects = true;
    }
  }

  if (subpattern) {
    // For signatures with pattern:
    // model.on('change', 'example.subpath.**', callback)
    // model.at('example').on('change', 'subpath', callback)
    var pattern = model.path(subpattern);
    return (useEventObjects) ?
      modelEventListener(eventType, pattern, cb, model._eventContext) :
      modelEventListenerLegacy(pattern, cb, model._eventContext);
  }
  // For signature without explicit pattern:
  // model.at('example').on('change', callback)
  /** @type string */
  var path = model.path();
  if (path) {
    return (useEventObjects) ?
      modelEventListener(eventType, path, cb, model._eventContext) :
      modelEventListenerLegacy(path, cb, model._eventContext);
  }
  // For signature:
  // model.on('normalEvent', callback)
  return cb;
}

/**
 * Legacy version of `modelEventListener` that calls `cb` with var-args
 * `(captures..., [eventType], args..., passed)` instead of new-style
 * `___Event` objects.
 *
 * @param {string} pattern
 * @param {Function} cb
 * @param {*} eventContext
 * @return {ModelListenerFn & ModelListenerProps}
 */
function modelEventListenerLegacy(pattern, cb, eventContext) {
  var patternSegments = util.castSegments(pattern.split('.'));
  var testFn = testPatternFn(pattern, patternSegments);

  /** @type ModelListenerFn */
  function modelListener(segments, eventArgs) {
    var captures = testFn(segments);
    if (!captures) return;

    var args = (captures.length) ? captures.concat(eventArgs) : eventArgs;
    cb.apply(null, args);
    return true;
  }

  // Used in Model#removeAllListeners
  modelListener.pattern = pattern;
  modelListener.patternSegments = patternSegments;
  modelListener.eventContext = eventContext;

  return modelListener;
}

/**
 * Returns a function that can be passed to `EventEmitter#on`, with some
 * additional properties used for `Model#removeAllListeners`.
 *
 * When the function is called, it checks if the event matches `patternArg`, and
 * if there's a match, it calls `cb`.
 *
 * @param {string} eventType
 * @param {string} pattern
 * @param {Function} cb
 * @param {*} eventContext
 * @return {ModelListenerFn & ModelListenerProps}
 */
function modelEventListener(eventType, pattern, cb, eventContext) {
  var patternSegments = util.castSegments(pattern.split('.'));
  var testFn = testPatternFn(pattern, patternSegments);

  var eventFactory = getEventFactory(eventType);
  /** @type ModelListenerFn */
  function modelListener(segments, eventArgs) {
    var captures = testFn(segments);
    if (!captures) return;

    var event = eventFactory(eventArgs);
    cb(event, captures);
    return true;
  }

  // Used in Model#removeAllListeners
  modelListener.pattern = pattern;
  modelListener.patternSegments = patternSegments;
  modelListener.eventContext = eventContext;

  return modelListener;
}

/** @typedef { (segments: string[], eventArgs: any[]) => (boolean | undefined) } ModelListenerFn */
/** @typedef { {pattern: string, patternSegments: Array<string | number>, eventContext: any} } ModelListenerProps */

/**
 * Returns a factory function that creates an `___Event` object based on an
 * old-style `eventArgs` array.
 *
 * @param {string} eventType
 * @return {(eventArgs: any[]) => ChangeEvent | InsertEvent | RemoveEvent | MoveEvent | LoadEvent | UnloadEvent}
 */
function getEventFactory(eventType) {
  switch (eventType) {
    case 'change':
      return function(eventArgs) {
        return new ChangeEvent(eventArgs);
      };
    case 'insert':
      return function(eventArgs) {
        return new InsertEvent(eventArgs);
      };
    case 'remove':
      return function(eventArgs) {
        return new RemoveEvent(eventArgs);
      };
    case 'move':
      return function(eventArgs) {
        return new MoveEvent(eventArgs);
      };
    case 'load':
      return function(eventArgs) {
        return new LoadEvent(eventArgs);
      };
    case 'unload':
      return function(eventArgs) {
        return new UnloadEvent(eventArgs);
      };
    case 'all':
      return function(eventArgs) {
        var concreteEventType = eventArgs[0]; // 'change', 'insert', etc.
        var concreteEventFactory = getEventFactory(concreteEventType);
        return concreteEventFactory(eventArgs.slice(1));
      };
    default: throw new Error('Unknown event: ' + eventType);
  }
}

// These constructors accept the `eventArgs` array format that Racer uses
// internally when calling `Model#emit`.
//
// Eventually, Racer should switch to passing these events around directly,
// but that will require updating all the places that parse the `eventArgs`
// array format, to extract things like `passed`.

function ChangeEvent(eventArgs) {
  this.value = eventArgs[0];
  this.previous = eventArgs[1];
  this.passed = eventArgs[2];
}
ChangeEvent.prototype.type = 'change';

function InsertEvent(eventArgs) {
  this.index = eventArgs[0];
  this.values = eventArgs[1];
  this.passed = eventArgs[2];
}
InsertEvent.prototype.type = 'insert';

function RemoveEvent(eventArgs) {
  this.index = eventArgs[0];
  this.removed = eventArgs[1];
  this.passed = eventArgs[2];
}
RemoveEvent.prototype.type = 'remove';

function MoveEvent(eventArgs) {
  this.from = eventArgs[0];
  this.to = eventArgs[1];
  this.howMany = eventArgs[2];
  this.passed = eventArgs[3];
}
MoveEvent.prototype.type = 'move';

function LoadEvent(eventArgs) {
  this.document = eventArgs[0];
  this.passed = eventArgs[1];
}
LoadEvent.prototype.type = 'load';

function UnloadEvent(eventArgs) {
  this.previousDocument = eventArgs[0];
  this.passed = eventArgs[1];
}
UnloadEvent.prototype.type = 'unload';

/**
 * Returns a function that tests an array of event segments against the
 * `patternSegments`. (`pattern` only matters if it's exactly `'**'`.)
 *
 * @param {string?} pattern
 * @param {Array<string | number>} patternSegments
 * @return {(segments: string[]) => (string[] | undefined)} A function to test
 *   an array of event segments. If the event segments match, an array of 0 or
 *   more segments captured by `'*'` / `'**'` is returned, one per wildcard. If
 *   the event segments don't match, `undefined` is returned.
 */
function testPatternFn(pattern, patternSegments) {
  if (pattern === '**') {
    return function testPattern(segments) {
      return [segments.join('.')];
    };
  }

  var endingRest = stripRestWildcard(patternSegments);

  return function testPattern(segments) {
    // Any pattern with more segments does not match
    var patternLen = patternSegments.length;
    if (patternLen > segments.length) return;

    // A pattern with the same number of segments matches if each
    // of the segments are wildcards or equal. A shorter pattern matches
    // if it ends in a rest wildcard and each of the corresponding
    // segments are wildcards or equal.
    if (patternLen === segments.length || endingRest) {
      /** @type string[] */
      var captures = [];
      for (var i = 0; i < patternLen; i++) {
        var patternSegment = patternSegments[i];
        var segment = segments[i];
        if (patternSegment === '*' || patternSegment === '**') {
          captures.push(segment);
          continue;
        }
        if (patternSegment !== segment) return;
      }
      if (endingRest) {
        var remainder = segments.slice(i).join('.');
        captures.push(remainder);
      }
      return captures;
    }
  };
}

/**
 * @param {Array<string | number>} segments
 */
function stripRestWildcard(segments) {
  // ['example', '**'] -> ['example']; return true
  var lastIndex = segments.length - 1;
  var lastSegment = segments[lastIndex];
  if (lastSegment === '**') {
    segments.pop();
    return true;
  }
  // ['example', 'subpath**'] -> ['example', 'subpath']; return true
  if (typeof lastSegment !== 'string') return false;
  var match = /^([^\*]+)\*\*$/.exec(lastSegment);
  if (!match) return false;
  segments[lastIndex] = match[1];
  return true;
}
